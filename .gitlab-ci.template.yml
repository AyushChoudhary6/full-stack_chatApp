# GitLab CI/CD Pipeline Template
# Copy this file and customize for your specific environment

stages:
  - validate
  - test
  - security
  - build
  - push
  - deploy

variables:
  # Customize these variables for your environment
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Container Registry - Update with your registry
  REGISTRY_URL: "your-registry.com"
  REGISTRY_USER: "your-username"
  BACKEND_IMAGE: "$REGISTRY_URL/chat-app-backend:$CI_COMMIT_SHORT_SHA"
  FRONTEND_IMAGE: "$REGISTRY_URL/chat-app-frontend:$CI_COMMIT_SHORT_SHA"
  LATEST_BACKEND_IMAGE: "$REGISTRY_URL/chat-app-backend:latest"
  LATEST_FRONTEND_IMAGE: "$REGISTRY_URL/chat-app-frontend:latest"
  
  # Kubernetes Configuration
  K8S_NAMESPACE: "chat-app"
  K8S_CONTEXT: "your-cluster-context"
  
  # Environment URLs
  DEV_URL: "https://dev-chat-app.yourdomain.com"
  STAGING_URL: "https://staging-chat-app.yourdomain.com"
  PROD_URL: "https://chat-app.yourdomain.com"

# Cache dependencies for faster builds
cache:
  key: $CI_COMMIT_REF_SLUG
  paths:
    - backend/node_modules/
    - frontend/node_modules/

# Include this section if you want to use GitLab's built-in security scanning
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml

# -------------------------
# Validate Stage
# -------------------------

lint_backend:
  stage: validate
  image: node:20-alpine
  script:
    - cd backend
    - npm ci
    - npm run lint
  artifacts:
    reports:
      junit: backend/lint-report.xml
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

lint_frontend:
  stage: validate
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run lint
  artifacts:
    reports:
      junit: frontend/lint-report.xml
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

# -------------------------
# Test Stage
# -------------------------

test_backend:
  stage: test
  image: node:20-alpine
  services:
    - mongo:6.0
  variables:
    MONGODB_URI: "mongodb://mongo:27017/test"
    NODE_ENV: "test"
  script:
    - cd backend
    - npm ci
    - npm test
  artifacts:
    reports:
      junit: backend/test-report.xml
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

test_frontend:
  stage: test
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run test || echo "Frontend tests not configured yet"
  artifacts:
    reports:
      junit: frontend/test-report.xml
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

# -------------------------
# Security Stage
# -------------------------

# Custom security scan for dependencies
security_scan:
  stage: security
  image: node:20-alpine
  script:
    - cd backend
    - npm ci
    - npm audit --audit-level=moderate || true
    - cd ../frontend
    - npm ci
    - npm audit --audit-level=moderate || true
  artifacts:
    reports:
      sast: security-report.json
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

# -------------------------
# Build Stage
# -------------------------

build_backend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker build -t $BACKEND_IMAGE -t $LATEST_BACKEND_IMAGE ./backend
    - docker save -o backend.tar $BACKEND_IMAGE
  artifacts:
    paths:
      - backend.tar
    expire_in: 2 hours
  only:
    - main
    - develop

build_frontend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker build -t $FRONTEND_IMAGE -t $LATEST_FRONTEND_IMAGE ./frontend
    - docker save -o frontend.tar $FRONTEND_IMAGE
  artifacts:
    paths:
      - frontend.tar
    expire_in: 2 hours
  only:
    - main
    - develop

# -------------------------
# Push Stage
# -------------------------

push_images:
  stage: push
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  dependencies:
    - build_backend
    - build_frontend
  script:
    # Update this section with your registry authentication
    - echo $REGISTRY_PASSWORD | docker login -u $REGISTRY_USER $REGISTRY_URL --password-stdin
    - docker load -i backend.tar
    - docker load -i frontend.tar
    - docker push $BACKEND_IMAGE
    - docker push $LATEST_BACKEND_IMAGE
    - docker push $FRONTEND_IMAGE
    - docker push $LATEST_FRONTEND_IMAGE
  only:
    - main
    - develop

# -------------------------
# Deploy Stage
# -------------------------

# Deploy to Development Environment
deploy_develop:
  stage: deploy
  image: bitnami/kubectl:latest
  needs: ["push_images"]
  environment:
    name: development
    url: $DEV_URL
    kubernetes:
      namespace: $K8S_NAMESPACE-dev
  script:
    - kubectl version --client
    - kubectl config use-context $K8S_CONTEXT
    - kubectl get nodes
    
    # Create namespace if it doesn't exist
    - kubectl create namespace $K8S_NAMESPACE-dev --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply Kubernetes manifests
    - kubectl apply -f k8s/ --recursive
    
    # Update deployment images
    - kubectl set image deployment/backend backend=$BACKEND_IMAGE -n $K8S_NAMESPACE-dev
    - kubectl set image deployment/frontend frontend=$FRONTEND_IMAGE -n $K8S_NAMESPACE-dev
    
    # Wait for rollout
    - kubectl rollout status deployment/backend -n $K8S_NAMESPACE-dev --timeout=300s
    - kubectl rollout status deployment/frontend -n $K8S_NAMESPACE-dev --timeout=300s
    
    # Show status
    - kubectl get pods -n $K8S_NAMESPACE-dev
    - kubectl get services -n $K8S_NAMESPACE-dev
  only:
    - develop

# Deploy to Staging Environment
deploy_staging:
  stage: deploy
  image: bitnami/kubectl:latest
  needs: ["push_images"]
  environment:
    name: staging
    url: $STAGING_URL
    kubernetes:
      namespace: $K8S_NAMESPACE-staging
  script:
    - kubectl version --client
    - kubectl config use-context $K8S_CONTEXT
    - kubectl get nodes
    
    # Create namespace if it doesn't exist
    - kubectl create namespace $K8S_NAMESPACE-staging --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply Kubernetes manifests
    - kubectl apply -f k8s/ --recursive
    
    # Update deployment images
    - kubectl set image deployment/backend backend=$BACKEND_IMAGE -n $K8S_NAMESPACE-staging
    - kubectl set image deployment/frontend frontend=$FRONTEND_IMAGE -n $K8S_NAMESPACE-staging
    
    # Wait for rollout
    - kubectl rollout status deployment/backend -n $K8S_NAMESPACE-staging --timeout=300s
    - kubectl rollout status deployment/frontend -n $K8S_NAMESPACE-staging --timeout=300s
    
    # Show status
    - kubectl get pods -n $K8S_NAMESPACE-staging
    - kubectl get services -n $K8S_NAMESPACE-staging
  only:
    - main
  when: manual

# Deploy to Production Environment
deploy_production:
  stage: deploy
  image: bitnami/kubectl:latest
  needs: ["push_images"]
  environment:
    name: production
    url: $PROD_URL
    kubernetes:
      namespace: $K8S_NAMESPACE
  script:
    - kubectl version --client
    - kubectl config use-context $K8S_CONTEXT
    - kubectl get nodes
    
    # Create namespace if it doesn't exist
    - kubectl create namespace $K8S_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply Kubernetes manifests
    - kubectl apply -f k8s/ --recursive
    
    # Update deployment images
    - kubectl set image deployment/backend backend=$BACKEND_IMAGE -n $K8S_NAMESPACE
    - kubectl set image deployment/frontend frontend=$FRONTEND_IMAGE -n $K8S_NAMESPACE
    
    # Wait for rollout
    - kubectl rollout status deployment/backend -n $K8S_NAMESPACE --timeout=300s
    - kubectl rollout status deployment/frontend -n $K8S_NAMESPACE --timeout=300s
    
    # Health check
    - echo "Performing health checks..."
    - sleep 30
    - kubectl get pods -n $K8S_NAMESPACE -o wide
  only:
    - main
  when: manual

# -------------------------
# Post-Deployment Tasks
# -------------------------

# Notify deployment status
notify_deployment:
  stage: .post
  image: curlimages/curl:latest
  script:
    - echo "Deployment notification would be sent here"
    - echo "Update with your notification service (Slack, Teams, etc.)"
  dependencies:
    - deploy_production
  only:
    - main
  when: on_success
