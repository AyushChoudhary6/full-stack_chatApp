# =============================================================================
# GitLab CI/CD Pipeline for Local Chat Application
# =============================================================================
# PostgreSQL database, GitLab Container Registry, local deployment with GitLab Runner

stages:
  - test
  - build
  - deploy

variables:
  # Docker configuration
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2
  
  # GitLab Container Registry images
  BACKEND_IMAGE: "${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHORT_SHA}"
  FRONTEND_IMAGE: "${CI_REGISTRY_IMAGE}/frontend:${CI_COMMIT_SHORT_SHA}"
  
  # Database configuration
  POSTGRES_DB: chatapp
  POSTGRES_USER: chatapp_user

# =============================================================================
# TEST STAGE
# =============================================================================

test_backend:
  stage: test
  image: node:18-alpine
  services:
    - postgres:13-alpine
  variables:
    POSTGRES_DB: test_chatapp
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: "postgresql://test_user:test_password@postgres:5432/test_chatapp"
  before_script:
    - cd backend
    - npm ci
  script:
    - npm run test || echo "No tests configured yet"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

build_frontend:
  stage: test
  image: node:18-alpine
  before_script:
    - cd frontend
    - npm ci
  script:
    - npm run build
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# =============================================================================
# BUILD STAGE - Docker Images with Registry Push
# =============================================================================

build_backend_image:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - cd backend
    - docker build -t $BACKEND_IMAGE .
    - docker push $BACKEND_IMAGE
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

build_frontend_image:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - cd frontend
    - docker build -t $FRONTEND_IMAGE .
    - docker push $FRONTEND_IMAGE
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# =============================================================================
# DEPLOY STAGE - Pull from Registry and Deploy
# =============================================================================

deploy_local:
  stage: deploy
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Install docker-compose
    - apk add --no-cache curl
    - curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose
    - chmod +x /usr/local/bin/docker-compose
  script:
    # Pull the images from registry
    - docker pull $BACKEND_IMAGE
    - docker pull $FRONTEND_IMAGE
    
    # Create docker-compose.yml for local deployment
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      
      services:
        postgres:
          image: postgres:13-alpine
          environment:
            POSTGRES_DB: ${POSTGRES_DB}
            POSTGRES_USER: ${POSTGRES_USER}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
          volumes:
            - postgres_data:/var/lib/postgresql/data
          ports:
            - "5432:5432"
          healthcheck:
            test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
            interval: 10s
            timeout: 5s
            retries: 5
        
        backend:
          image: ${BACKEND_IMAGE}
          environment:
            DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
            JWT_SECRET: ${JWT_SECRET}
            PORT: 5000
            NODE_ENV: production
          ports:
            - "5000:5000"
          depends_on:
            postgres:
              condition: service_healthy
          restart: unless-stopped
        
        frontend:
          image: ${FRONTEND_IMAGE}
          ports:
            - "3000:80"
          depends_on:
            - backend
          restart: unless-stopped
      
      volumes:
        postgres_data:
      EOF
    
    # Deploy the application
    - docker-compose -f docker-compose.prod.yml down || true
    - docker-compose -f docker-compose.prod.yml up -d
    
    # Wait for services to be ready
    - sleep 30
    
    # Check if services are running
    - docker-compose -f docker-compose.prod.yml ps
    
    # Display service URLs
    - echo "Deployment completed successfully!"
    - echo "Frontend available at http://localhost:3000"
    - echo "Backend API available at http://localhost:5000"
    - echo "PostgreSQL available at localhost:5432"
    - echo "Health Check available at http://localhost:5000/health"
    
  environment:
    name: local
    url: http://localhost:3000
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
    - if: $CI_COMMIT_BRANCH == "develop"
  allow_failure: false
