# =============================================================================
# GitLab CI/CD Pipeline for Full-Stack Chat Application
# =============================================================================
# Docker + Kubernetes deployment with PostgreSQL and GitLab Container Registry

stages:
  - test
  - build
  - deploy-docker
  - deploy-k8s

variables:
  # Docker configuration
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2
  
  # GitLab Container Registry images
  BACKEND_IMAGE: "${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHORT_SHA}"
  FRONTEND_IMAGE: "${CI_REGISTRY_IMAGE}/frontend:${CI_COMMIT_SHORT_SHA}"
  
  # Database configuration
  POSTGRES_DB: chatapp
  POSTGRES_USER: chatapp_user
  
  # Kubernetes configuration
  KUBE_NAMESPACE: chatapp
  KUBE_CONTEXT: default

# =============================================================================
# TEST STAGE
# =============================================================================

test_backend:
  stage: test
  image: node:18-alpine
  services:
    - postgres:13-alpine
  variables:
    POSTGRES_DB: test_chatapp
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: "postgresql://test_user:test_password@postgres:5432/test_chatapp"
  before_script:
    - cd backend
    - npm ci
  script:
    - npm run test || echo "No tests configured yet"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

build_frontend:
  stage: test
  image: node:18-alpine
  before_script:
    - cd frontend
    - npm ci
  script:
    - npm run build
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# =============================================================================
# BUILD STAGE - Docker Images with Registry Push
# =============================================================================

build_backend_image:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - cd backend
    - docker build -t $BACKEND_IMAGE .
    - docker push $BACKEND_IMAGE
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

build_frontend_image:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - cd frontend
    - docker build -t $FRONTEND_IMAGE .
    - docker push $FRONTEND_IMAGE
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# =============================================================================
# DEPLOY STAGE - Docker Compose (Development/Testing)
# =============================================================================

deploy_docker:
  stage: deploy-docker
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Install docker-compose
    - apk add --no-cache curl
    - curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose
    - chmod +x /usr/local/bin/docker-compose
  script:
    # Pull the images from registry
    - docker pull $BACKEND_IMAGE
    - docker pull $FRONTEND_IMAGE
    
    # Create docker-compose.yml for local deployment
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      
      services:
        postgres:
          image: postgres:13-alpine
          environment:
            POSTGRES_DB: ${POSTGRES_DB}
            POSTGRES_USER: ${POSTGRES_USER}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
          volumes:
            - postgres_data:/var/lib/postgresql/data
          ports:
            - "5432:5432"
          healthcheck:
            test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
            interval: 10s
            timeout: 5s
            retries: 5
        
        backend:
          image: ${BACKEND_IMAGE}
          environment:
            DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
            JWT_SECRET: ${JWT_SECRET}
            PORT: 5000
            NODE_ENV: production
          ports:
            - "5000:5000"
          depends_on:
            postgres:
              condition: service_healthy
          restart: unless-stopped
        
        frontend:
          image: ${FRONTEND_IMAGE}
          ports:
            - "3000:80"
          depends_on:
            - backend
          restart: unless-stopped
      
      volumes:
        postgres_data:
      EOF
    
    # Deploy the application
    - docker-compose -f docker-compose.prod.yml down || true
    - docker-compose -f docker-compose.prod.yml up -d
    
    # Wait for services to be ready
    - sleep 30
    
    # Check if services are running
    - docker-compose -f docker-compose.prod.yml ps
    
    # Display service URLs
    - echo "Docker Deployment completed successfully!"
    - echo "Frontend available at http://localhost:3000"
    - echo "Backend API available at http://localhost:5000"
    - echo "PostgreSQL available at localhost:5432"
    
  environment:
    name: docker-local
    url: http://localhost:3000
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: false

# =============================================================================
# DEPLOY STAGE - Kubernetes (Production)
# =============================================================================

deploy_kubernetes:
  stage: deploy-k8s
  image: bitnami/kubectl:latest
  before_script:
    # Install kubectl and other tools
    - apk add --no-cache curl bash
    # Create kubectl config directory
    - mkdir -p ~/.kube
    # Setup kubeconfig (assuming you have a local cluster)
    - echo "Setting up kubectl for local cluster..."
  script:
    # Create namespace if it doesn't exist
    - kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # Create ConfigMap for environment variables
    - |
      cat > configmap.yaml << EOF
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: chatapp-config
        namespace: $KUBE_NAMESPACE
      data:
        POSTGRES_DB: "${POSTGRES_DB}"
        POSTGRES_USER: "${POSTGRES_USER}"
        NODE_ENV: "production"
        PORT: "5000"
      EOF
    - kubectl apply -f configmap.yaml
    
    # Create Secret for sensitive data
    - |
      cat > secret.yaml << EOF
      apiVersion: v1
      kind: Secret
      metadata:
        name: chatapp-secrets
        namespace: $KUBE_NAMESPACE
      type: Opaque
      data:
        POSTGRES_PASSWORD: $(echo -n "${POSTGRES_PASSWORD}" | base64)
        JWT_SECRET: $(echo -n "${JWT_SECRET}" | base64)
        DATABASE_URL: $(echo -n "postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-service:5432/${POSTGRES_DB}" | base64)
      EOF
    - kubectl apply -f secret.yaml
    
    # Update Kubernetes manifests with new image tags
    - sed -i "s|BACKEND_IMAGE_PLACEHOLDER|${BACKEND_IMAGE}|g" k8s/backend-deployment.yml
    - sed -i "s|FRONTEND_IMAGE_PLACEHOLDER|${FRONTEND_IMAGE}|g" k8s/frontend-deployment.yml
    
    # Deploy PostgreSQL
    - kubectl apply -f k8s/postgres-deployment.yml
    
    # Deploy Backend
    - kubectl apply -f k8s/backend-deployment.yml
    - kubectl apply -f k8s/backend-service.yml
    
    # Deploy Frontend
    - kubectl apply -f k8s/frontend-deployment.yml
    - kubectl apply -f k8s/frontend-service.yml
    
    # Apply Ingress (if available)
    - kubectl apply -f k8s/ingress.yml || echo "Ingress not applied - may not be needed for local setup"
    
    # Wait for deployments
    - echo "Waiting for deployments to be ready..."
    - kubectl wait --for=condition=available --timeout=300s deployment/postgres-deployment -n $KUBE_NAMESPACE
    - kubectl wait --for=condition=available --timeout=300s deployment/backend-deployment -n $KUBE_NAMESPACE
    - kubectl wait --for=condition=available --timeout=300s deployment/frontend-deployment -n $KUBE_NAMESPACE
    
    # Get service information
    - echo "Kubernetes Deployment completed!"
    - echo "Services:"
    - kubectl get services -n $KUBE_NAMESPACE
    - echo "Pods:"
    - kubectl get pods -n $KUBE_NAMESPACE
    - echo "To access the application:"
    - echo "Frontend port-forward command kubectl port-forward service/frontend-service 3000:80 -n $KUBE_NAMESPACE"
    - echo "Backend port-forward command kubectl port-forward service/backend-service 5000:5000 -n $KUBE_NAMESPACE"
    
  environment:
    name: kubernetes-local
    url: http://localhost:3000
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
      when: manual
  allow_failure: false
